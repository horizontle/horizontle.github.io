<!DOCTYPE html>
<html>
<body>
<style>
.grid { 
    /* top right bot left */
    /* margin:100px 50px 20px 40px;  */
    margin:5em 1em 2em 10em; 
    border-collapse:collapse 
}
.grid td {
    cursor:pointer;
    width:50px; height:50px;
    border:2px solid #ccc;
    /* text-align:center; */
    /* font-family:sans-serif; font-size:13px */
}
.grid td.clicked {
    background-color:darkgrey;
    /* font-weight:bold; color:red; */
}

.lake { 
    /* top right bot left */
    /* margin:100px 50px 20px 40px;  */
    margin:1em 1em 1em 1em; 
    border-collapse:collapse;
    float: left;
}
.lake td {
    /* cursor:pointer; */
    width:20px; height:20px;
    border:2px solid #ccc;
    /* text-align:center; */
    /* font-family:sans-serif; font-size:13px */
}
.lake td.clicked {
    background-color:	#505050;
    /* font-weight:bold; color:red; */
}
.lake td.extra {
    background-color:palevioletred;
    /* font-weight:bold; color:red; */
}
.lake td.missing {
    background-color:palegreen;
    /* font-weight:bold; color:red; */
}
</style>

<p>Click "Try it" to call a function with arguments</p>

<p id="demo"></p>

<button onclick="solve(user_lake)">Try it</button>

<p id="output"></p>

<script>
var user_lake = [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]];
var grid = clickableGrid(5,5);

document.getElementById("demo").appendChild(grid);

function handleClick(cell, r, c, i) {
    // console.log("You clicked on item #:",r);
    if (cell.className === 'clicked') {
        cell.className = ''
        user_lake[r][c] = 0;
    }
    else {
        cell.className = 'clicked'
        user_lake[r][c] = 1;
    }
    // console.log(cell.className)
    // console.log(JSON.stringify(user_lake))
}

function eventClickHandler(cell, r, c, i) {
    return function() {
        handleClick(cell, r, c, i)
    }
}

function clickableGrid(rows, cols) {
    var i=0;
    var grid = document.createElement('table');
    grid.className = 'grid';
    for (var r=0;r<rows;++r){
        var tr = grid.appendChild(document.createElement('tr'));
        for (var c=0;c<cols;++c){
            var cell = tr.appendChild(document.createElement('td'));
            i += 1;
            // cell.innerHTML = ++i;
            cell.addEventListener(
                'click',
                eventClickHandler(cell, r, c, i),
                false
            );
        }
    }
    return grid;
}

function drawLake(lake) {
    var grid = document.createElement('table');
    grid.className = 'lake';
    for (var r=0;r<5;++r){
        var tr = grid.appendChild(document.createElement('tr'));
        for (var c=0;c<5;++c){
            var cell = tr.appendChild(document.createElement('td'));
            if (lake[r][c] == 1) {
                cell.className = 'clicked'
            }
            if (lake[r][c] == 2) {
                cell.className = 'extra'
            }
            if (lake[r][c] == 3) {
                cell.className = 'missing'
            }
            // cell.addEventListener(
            //     'click',
            //     eventClickHandler(cell, r, c, i),
            //     false
            // );
        }
    }
    document.getElementById("output").appendChild(grid);
    // document.getElementById("demo").appendChild(grid.cloneNode(true));
    return grid;
}

function drawDiff(current_lake, goal_lake) {
    annotated_lake = JSON.parse(JSON.stringify(empty_lake))
    for (var r=0;r<5;++r) {
        for (var c=0;c<5;++c) {
            if ((current_lake[r][c] == 1) && (goal_lake[r][c] == 1)) {
                annotated_lake[r][c] = 1
            }
            else {
                if (current_lake[r][c] == 1) {
                    annotated_lake[r][c] = 2
                }
                if (goal_lake[r][c] == 1) {
                    annotated_lake[r][c] = 3
                }
            }
        }
    }
    drawLake(annotated_lake);
}

function solve(user_lake) {
    var closest_lakes = findClosestMatch(user_lake)
    console.log(closest_lakes.length)
    // document.getElementById("output").replaceChild();
    while (document.getElementById("output").hasChildNodes()) {
        document.getElementById("output").removeChild(document.getElementById("output").firstChild);
    }
    for (var i = 0; i<Math.min(closest_lakes.length,5);i++) {
        drawDiff(user_lake, closest_lakes[i])
        // drawLake(closest_lakes[i])
    }
}


let empty_lake = [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]];

let x = 5;
function myFunction(name,job) {
  document.getElementById("demo").innerHTML = "Welcome " + name + ", the " + job + ".";
}

function rotateLake(lake) {
    rotated_lake = JSON.parse(JSON.stringify(lake));
    for (var r = 0; r < 5; r++) {
        for (var c = 0; c < 5; c++) {
            rotate_c = 4 - r
            rotate_r = c
            rotated_lake[rotate_r][rotate_c] = lake[r][c]
        }
    }
    return rotated_lake
}

function flipLake(lake) {
    flipped_lake = JSON.parse(JSON.stringify(empty_lake))
    for (var r = 0; r < 5; r++) {
        for (var c = 0; c < 5; c++) {
            flipped_lake[c][r] = lake[r][c]
        }
    }
    return flipped_lake
}

function getPermutations(lake, existing_lakes){
    let r_lake = lake;
    for (var i = 0; i < 4; i++) {
        r_lake = rotateLake(r_lake);
        f_lake = flipLake(r_lake);
        contains_rotate = false;
        contains_flip = false;
        for (var li = 0; li < existing_lakes.length; li++) {
            let existing_lake = existing_lakes[li]
            if (JSON.stringify(r_lake) === JSON.stringify(existing_lake)) {
                contains_rotate = true;
            }
            if (JSON.stringify(f_lake) === JSON.stringify(existing_lake)) {
                contains_flip = true;
            }   
        }
        if (JSON.stringify(f_lake) === JSON.stringify(r_lake)) {
            contains_flip = true;
        }
        if (!contains_rotate) {
            existing_lakes.push(JSON.parse(JSON.stringify(r_lake)));
        }
        if (!contains_flip) {
            existing_lakes.push(JSON.parse(JSON.stringify(f_lake)));
        }   
    }
    return existing_lakes
}

// calculated these in python with recursive backtracking
let t0 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 1, 0, 1]]';
let t1 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 1, 1], [1, 1, 1, 1, 0]]';
let t2 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]';
let t3 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]';
let t4 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 0, 1, 1], [0, 1, 1, 1, 0]]';
let t5 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [1, 1, 0, 0, 1], [0, 1, 1, 1, 1]]';
let t6 = '[[1, 0, 1, 1, 1], [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [0, 1, 1, 1, 1]]';
let t7 = '[[1, 0, 1, 1, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 1], [1, 1, 1, 0, 1], [1, 0, 1, 1, 1]]';

function getBestLakes() {
    let best_lakes = [];
    best_lakes.push(JSON.parse(t0));
    best_lakes.push(JSON.parse(t1));
    best_lakes.push(JSON.parse(t2));
    best_lakes.push(JSON.parse(t3));
    best_lakes.push(JSON.parse(t4));
    best_lakes.push(JSON.parse(t5));
    best_lakes.push(JSON.parse(t6));
    best_lakes.push(JSON.parse(t7));
    var loop_length = best_lakes.length
    for (var li = 0; li < loop_length; li++) {
        best_lakes = getPermutations(best_lakes[li], best_lakes)
    }
    return best_lakes
}

function numSwaps(lake1, lake2) {
    let count = 0
    for (var r = 0; r < 5; r++) {
        for (var c = 0; c < 5; c++) {
            if (lake1[r][c] == 1) {
                if (lake2[r][c] == 0) {
                    count += 1
                }
            }
        }
    }
    return count;
}

function findClosestMatch(current_lake) {
    let lakes = getBestLakes();
    let best_distance = 99;
    let output = []
    for (var li = 0; li < lakes.length; li++) {
        let template_lake = lakes[li]
        let distance = numSwaps(current_lake, template_lake)
        if (distance < best_distance) {
            best_distance = distance
        }   
    }
    for (var li = 0; li < lakes.length; li++) {
        let template_lake = lakes[li]
        let distance = numSwaps(current_lake, template_lake)
        if (distance == best_distance) {
            output.push(template_lake)
        }   
    }
    console.log(best_distance)
    return output
}



let lake2 = ([
    [0,1,1,1,1],
    [0,1,0,0,1],
    [0,1,0,1,1],
    [0,0,1,0,1],
    [0,0,1,1,1]
])

let lake3 = ([
    [1,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0]
])



</script>

</body>
</html>